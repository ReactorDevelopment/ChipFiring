Matrix tree theorem directed graphs

Invariant factors of Jacobian of cycle graphs with no paths:
    This is always Z_n.

Invariant factors of Jacobian of cycle graphs with one path:
    This is always trivial.

Invariant factors of Jacobian of cycle graphs with two paths:
    Possible way of generalization: prove that two paths always use up all
    available higher invariant factors

    Invariant factor depends only on number of zeroes clockwise of the
    counter-clockwise path and counter-clockwise of the clockwise path.
    The other ends of these paths can grow or shrink, and it will not
    change the invariant factor.  The invariant factor produced is always
    >[REDO]< where x is the number of zeroes in that section between the paths.

    It does also seem to not matter if the inside of this path is broken up be zeroes.
    This means that the inside of these paths can be anything as long as the
    cc paths and the c paths do not cross.

Invariant factors of Jacobian of cycle graphs with more than two paths:
    This refers to any configuration that are not covered by the two paths configurations.
    The only factors that I have noticed for these paths is Z_2 and the trivial group.

Wheel graphs:
    Graph.wheel(size, direction=1, spoke_direction=2) inv factors followed Z_(2^(size-1)-1) x Z

    Graph.wheel(size, direction=2, spoke_direction=1) inv factors followed Z_(size-1) x Z

    Graph.wheel(size, direction=1, spoke_direction=1) same as Graph.wheel(size, direction=2, spoke_direction=1)

    Graph.wheel(size, direction=2, spoke_direction=2) same as Graph.wheel(size, direction=1, spoke_direction=2)

    Graph.wheel(size, direction=0, spoke_direction=0) inv factors followed
        .27555(golden_ratio^{x}) x 5*.27555(golden_ratio^{x}) x Z for odd sizes
    Graph.wheel(size, direction=0, spoke_direction=0) inv factors followed
        .618035(golden_ratio^{x}) x .618035(golden_ratio^{x}) x Z for even sizes

    Graph.wheel(size, direction=0, spoke_direction=1) inv factors followed Z_(n-1) x Z_(n-1) X Z for even sizes
    Graph.wheel(size, direction=0, spoke_direction=1) inv factors followed Z_((n-1)/2) x Z_((n-1)*2) X Z for odd sizes

    Graph.wheel(size, direction=0, spoke_direction=2) same as Graph.wheel(size, direction=0, spoke_direction=0)

    Graph.wheel(size, direction=2, spoke_direction=0) same as Graph.wheel(size, direction=1, spoke_direction=2)

    Graph.wheel(size, direction=1, spoke_direction=0) same as Graph.wheel(size, direction=1, spoke_direction=2)


Check for pattern un P, Q in PAQ = Smith when growing P and Q to fit larger cycles.  Maybe check for pattern
in growing smith itself or growing laplacian

Check 4, 6, 8 ... paths for cyclic graphs to determine if they all have Z ... Z_n invariant factors

bipartite graph

Three layers in the form of f -> s -> t where f, s, t are the number of nodes in each layer

if t is odd:
    if s is odd:
        if s is not a factor of t:
            if f <= s:
                (s-f-1)Z_(t) x (f)Z_(s*t) x Z^t
            else:
                (f-s+1)Z_s x (s-1)Z_(s*t) x Z^t
        else:
            (f-1)Z_s x Z_t x Z_(s*t) x Z^t
    else:
        if f <= s:
            (s-f-1)Z_(t) x (f)Z_(s*t) x Z^t
        else:
            (f-s+1)Z_s x (s-1)Z_(s*t) x Z^t

else:
    if s is odd:
        if s is not a factor of t:
            if f <= s:
                (s-f-1)Z_(t) x (f)Z_(s*t) x Z^t
            else:
                (f-s+1)Z_s x (s-1)Z_(s*t) x Z^t
        else:
            (f-1)Z_s x Z_t x Z_(s*t) x Z^t
    else:
        if s is a factor of t:
            (f-1)Z_s x Z_t x Z_(s*t) x Z^t
        else:
            (f-1)Z_2 x (s-f-1)Z_t x (f-1)Z_(s*t/2) x Z_(s*t) x Z^t

Two layers in the form of f -> s where f, s are the number of nodes in each layer
(f-1)Z_(s) x Z^s


directed matrix tree theorem
proving cycle graphs by splitting laplacian between paths


Clear central diagonal by adding element of diagonal upwards and downwards.  This allows previous element in diagonal
to be able to freely clear its column since its entire row is now clear.  By definition, any bidirectional edges in
the diagonal have to have one -1 above or below it.  By only clearing the 1's first, all the 2's will be made into
ones by the time the first sweep has completed.  The new 1's can then clear their columns since their rows had
already been cleared, converting more 2's if there are any adjacent.  This results in a prefect identity matrix.

Merge sort for smith normal form