\documentclass[11pt,reqno]{amsart}
\usepackage{mathptmx}
\usepackage{mathtools}
\usepackage{mathrsfs}
\usepackage[all]{xy}
\usepackage{stmaryrd}
\usepackage{fancyhdr}

\usepackage{pgf, tikz}
\usetikzlibrary{arrows, automata}

\usepackage{tikz-cd}
\usepackage{cite}
\usepackage{amsmath,amsfonts}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{array}
\usepackage{amsmath,amsthm,amssymb,hyperref}
\usepackage{exercise}

\usepackage{enumerate}
\usepackage{tikz}
\pagestyle{plain}
\usepackage[left=1.2in, right=1.2in, top=1in, bottom=1in]{geometry}
\usepackage{etoolbox}
\usepackage{color}
\usepackage{xcolor}
\patchcmd{\section}{\scshape}{\bfseries}{}{}
\makeatletter
\renewcommand{\@secnumfont}{\bfseries}
\makeatother
\xyoption{all}
\thispagestyle{empty}

\DeclareMathOperator{\Hom}{Hom}
\DeclareMathOperator{\Spec}{Spec}
\DeclareMathOperator{\Spv}{Spv}
\DeclareMathOperator{\Frac}{Frac}
\DeclareMathOperator{\Img}{Img}
\DeclareMathOperator{\Ker}{Ker}
\DeclareMathOperator{\Pic}{Pic}
\DeclareMathOperator{\Div}{Div}
\DeclareMathOperator{\dv}{Div}
\DeclareMathOperator{\Deg}{deg}
\DeclareMathOperator{\Aut}{Aut}
\DeclareMathOperator{\CSpec}{Cspec}
\newcommand{\angles}[1]{\langle #1 \rangle}
\newcommand{\Jac}{\textrm{Jac}}{}
\newcommand{\R}{\mathbb{R}}  
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\I}{\mathbf{I}}

\input xy
\xyoption{all}
\thispagestyle{empty}


%\usepackage{secdot}

\theoremstyle{definition}
\newtheorem{mydef}{\textbf{Definition}}[section]
\newtheorem{myeg}[mydef]{\textbf{Example}}
\newtheorem{conj}[mydef]{\textbf{Conjecture}}
\newtheorem*{noconj}{\textbf{Conjecture}}
\newtheorem{observ}[mydef]{\textbf{Observation}}
\newtheorem{question}[mydef]{\textbf{Question}}
\newtheorem{rmk}[mydef]{\textbf{Remark}}
\newtheorem*{que}{\textbf{Question}}
\newtheorem*{goal}{\textbf{Goal}}

\theoremstyle{plain}
\newtheorem{mythm}[mydef]{\textbf{Theorem}}
\newtheorem*{nothm}{\textbf{Theorem}}
\newtheorem*{nomainthm}{\textbf{Main Theorem}}
\newtheorem*{nothma}{\textbf{Theorem A}}
\newtheorem*{nothmb}{\textbf{Theorem B}}
\newtheorem*{nothmc}{\textbf{Theorem C}}
\newtheorem*{nothmd}{\textbf{Theorem D}}
\newtheorem*{nothme}{\textbf{Theorem E}}
\newtheorem*{nothmf}{\textbf{Theorem F}}
\newtheorem*{nothmg}{\textbf{Theorem G}}
\newtheorem{mytheorem}[mydef]{\textbf{Theorem}}
\newtheorem{lem}[mydef]{\textbf{Lemma}}
\newtheorem{pro}[mydef]{\textbf{Proposition}}
\newtheorem{claim}[mydef]{\textbf{Claim}}
\newtheorem{cor}[mydef]{\textbf{Corollary}}
\newtheorem{con}[mydef]{\textbf{Construction}}


\patchcmd{\abstract}{\scshape\abstractname}{\normalsize{\textbf{\abstractname}}}{}{}
\begin{document}

\title{On Picard groups of directed graphs}

\author{Jaiung Jun}
\address{Department of Mathematics, State University of New York at New Paltz, NY 12561, USA}
\email{junj@newpaltz.edu}

\author{Matthew Pisano}
\address{Department of Mathematics, State University of New York at New Paltz, NY 12561, USA}
\email{pisanom1@newpaltz.edu}

%\makeatletter
%\@namedef{subjclassname@2020}{
%	\textup{2020} Mathematics Subject Classification}
%\makeatother

\subjclass[2020]{05C50, 05C76}
\keywords{Jacobian of a graph, sandpile group, critical group, chip-firing game, gluing graphs, cycle graph, Tutte
	polynomial, Tutte's rotor construction}

\maketitle

\begin{abstract}
	We explore a combinatorial game on finite graphs, called Chip-Firing Games,
	which has various connections to other areas, such as algebraic geometry, number theory and economics.
	To play the game, one first puts an integer amount of chips at each vertex. Then,
	each vertex is allowed to borrow or lend chips from its neighbors equally as the game progresses.
	One can study chip-firing games on a graph $G$ through a finitely generated abelian group
	$\textrm{Pic}(G)$ (Picard group) and its torsion subgroup $\textrm{Jac}(G)$ (Jacobian) which can
	be computed by using the Laplacian matrix of $G$.

	When a graph $G$ is directed, one may define $\textrm{Pic}(G)$ and $\textrm{Jac}(G)$ as in the case of undirected
	graphs by using Laplacian matrices, but computations become much more complicated in this case. For example,
	$\textrm{Pic}(G)=\mathbb{Z}$, when $G$ is a tree, from the matrix-tree theorem, which tells us that $|\textrm{Jac}(G)|$ is
	the number of spanning trees of $G$ in the undirected case.
	In the case of directed trees, even the rank of $\textrm{Pic}(T)$ can be arbitrarily large.
	For example, for any natural number $n$ we can construct a tree $T_n$ such that the rank of $\textrm{Pic}(T_n)$ is $n$.

	In our ongoing project, we study Picard groups and Jacobians for directed trees, cycles, and pseudotrees.
	Even in these seemingly simple cases, we find some new phenomenon. For instance, for the undirected cycle $C_n$,
	$\textrm{Jac}(C_n)=\mathbb{Z}_n$, however, we prove that in the directed case, for any given $m \leq n$, one can
	always find an orientation of $C_n$ in such a way that $\textrm{Jac}(C_n)$ is $\mathbb{Z}_m$.
	By closely examining trees and cycles, and how Picard groups and Jacobians change with (suitably defined)
	vertex and edge gluing, we obtain several results for pseudotrees.
\end{abstract}

\vspace*{\fill}

\textbf{Acknowledgment}\hspace{0.1cm} This research was supported by Research and Creative Activities (RSCA) at
SUNY New Paltz. We would like to thank RSCA for their support.

\pagebreak

\section{Introduction}
	This project will study Chip-Firing games and how different combinations of directed and undirected edges
	affect its winning strategies. We will focus on Research Project 11 in~\cite{glass2020chip}.
	We plan to pursue this for trees, cycle graphs, pseudotrees, and wheel graphs.

	%\begin{goal}[8/1/2022]$ $
	%	\begin{enumerate}
	%		\item
	%		Prove/disprove: for an oriented graph $G$, one always has $\Pic(G)=\mathbb{Z} \times \Jac(G)$,
	%		i.e., as a finitely generated abelian group, the rank of $\Pic(G)$ is $1$.
	%		\textcolor{red}{Jaiung: we disproved this by using~\cite{wagner2000critical}.}
	%		\item
	%		Prove/disprove: for $C_n$, and $0 \leq m \leq n$, one can always find an orientation
	%		of $C_n$ so that $\Jac(C_n)=\mathbb{Z}_m$ (with the orientation).
	%		\item
	%		Prove/disprove: for an oriented graph $G$, if $v_0 \in V(G)$ is a sink (or a source)
	%		and $G'$ is the graph obtained by reserving the direction for all arrows adjacent
	%		to $v_0$ from $G$, then $\Jac(G)=\Jac(G')$. (Note: we believe that this should be true
	%		for at least some classes of graphs such as cyclic graphs.)
	%		\item
	%		Prove/disprove: for an oriented planar graph $G$ and its planar dual (should be defined)
	%		$\hat{G}$, one has $\Jac(G)=\Jac(\hat{G})$.
	%		\item
	%		Prove/disprove: for oriented graphs $G_1,G_2$, let $G$ be the graph obtained by
	%		gluing $G_1$ and $G_2$ along one vertex. Then $\Jac(G)=\Jac(G_1) \times \Jac(G_2)$.
	%		\textcolor{red}{Jaiung: we are currently working on this (8/31)}
	%	\end{enumerate}
	%\end{goal}

\bigskip

\section{Preliminaries}

	\subsection{Chip Firing}
		The game at the heart of this paper is the Chip-Firing game. When a game is started, each vertex on
		a graph is assigned a certain number of chips.  During play, chips can be lent or borrowed at each
		node where one or more chips are either sent or received along each outgoing edge equally.  In the
		case of a directed graph, vertices can only interact with another along an outgoing or
		bidirectional edge.  The game is won once every vertex has a positive number of chips (i.e., this
		vertex is not in debt).

	\subsection{Divisors and Equivalence Relations}
		In the study of this game a \textbf{Divisor} of a graph ($\Div(G)$) is an integer vector $v\in\mathbb{Z}^n$
		where \textit{n} is the number of vertices in the graph.  The $i^{th}$ element of the vector \textit{v}
		is the number of chips on the $i^{th}$ vertex of the graph.  Two divisors have an \textbf{Equivalence Relation}
		($\sim$) if one divisor can be gotten from the other by a finite series of lending or borrowing moves
		$D_1 \sim D_2 \xleftrightarrow{} (D_1 \xleftrightarrow{\text{moves}} D_2)$.  An \textbf{Equivalence Class} \textit{[D]}
		is the set of all divisors that are equivalent to each other, $[D] = \{D_i~|~D_i \sim D\}$.

	\subsection{The Picard Group and The Jacobian}
		The \textbf{Picard Group} of a graph $\Pic(G)$ is the set of all equivalence classes that the
		divisors of that graph can be a  part of. The \textbf{Jacobian} of a graph  $\Jac(G)$ is a subset
		of $\Pic(G)$ such that every divisor in each equivalency class has a degree of $0$ where the
		degree of a divisor $\Deg(D)$ is the sum of each of the divisor's elements.
		If a divisor is in one of the Jacobian's classes, it can be made winning after a finite series of moves.
		Here, we represent the Picard Group as $\Pic(G)=\Jac(G)\times\mathbb{Z}^n$.


\section{Describing The Picard Group of a Tree}

	\begin{conj}
		The Jacobian of a tree graph is always trivial as follows from the matrix-tree theorem as a
		tree graph only has one possible spanning tree. \textcolor{red}{[Citation Needed]}
	\end{conj}

	\begin{lem}
		Let $G$ be a graph with any orientation. If we attach either an incoming arrow or a two-sided
		arrow to create a directed graph $G'$, then $\Pic(G)=\Pic(G')$. \label{proposition: gluing an arrow proposition}
	\end{lem}
	\begin{proof}
		Let $\alpha$ be an arrow which is glued to $G$. Let $|V(G)|=n$. We label the vertexes of
		$G$ as $1,2,\dots,n$. Suppose first that $\alpha$ is incoming and $\alpha$ is glued at the vertex $n$.
		Let $A_G=(a_{ij})$ (resp.~$A_{G'}$) be the Laplacian of $G$ (resp.~$G'$). In this case, one can easily
		observe that the matrix $A_{G'}$ is of the following form:
		\begin{equation}
			A_{G'}=\left[\begin{array}{ccc|c|c}
				a_{11}&a_{12}&\cdots &a_{1n}&0\\
				a_{21}&a_{22}&\cdots &a_{2n}&0\\
				\vdots & \vdots &\ddots & \vdots & \vdots \\ \hline
					\vdots & \vdots & \cdots&a_n & 0\\ \hline
				0&0&\cdots &-1&1\\
			\end{array}\right]
		\end{equation}
		By a column operation between the last two columns, we obtain the following matrix:
		\begin{equation}\label{eq: arrow adding matrix}
			\left[\begin{array}{ccc|c|c}
				a_{11}&a_{12}&\cdots &a_{1n}&0\\
				a_{21}&a_{22}&\cdots &a_{2n}&0\\
				\vdots & \vdots &\ddots & \vdots & \vdots \\ \hline
				\vdots & \vdots & \cdots&a_n & 0\\ \hline
				0&0&\cdots &0&1\\
			\end{array}\right]
		\end{equation}
		This shows that $\Pic(G)=\Pic(G')$.

		Next, suppose that $\alpha$ is a two-sided arrow. Then similar to the above, we obtain the following matroid for $G'$:
		\begin{equation}\label{eq: eq two-sided}
			A_{G'}=\left[\begin{array}{ccc|c|c}
				a_{11}&a_{12}&\cdots &a_{1n}&0\\
				a_{21}&a_{22}&\cdots &a_{2n}&0\\
				\vdots & \vdots &\ddots & \vdots & \vdots \\ \hline
				\vdots & \vdots & \cdots&a_n+1 & -1\\ \hline
				0&0&\cdots &-1&1\\
			\end{array}\right]
		\end{equation}
		By a column operation, the matrix~\eqref{eq: eq two-sided} becomes the matrix~\eqref{eq: arrow adding matrix}.
		This shows that $\Pic(G)=\Pic(G')$.
	\end{proof}

	\begin{pro}
		Let $T$ be a tree with any orientation. Then $\Pic(T)=\mathbb{Z}^n$, where $n$ is the number of sinks of $T$.
	\end{pro}
	\begin{proof}

		Note that from~\cite[Corollary 3.5]{wagner2000critical} that the rank of $\Pic(T)$ is the number of sinks of $T$.

		Now, we can inductively prove this. When $T_0$ is a tree with one arrow, one can easily check that
		$\Pic(T_0) =\mathbb{Z}$ or $\{0\}$ (depending on the number of sinks). Suppose that $T_k$ is a directed tree
		with $k$ arrows. When we add one arrow $\alpha$ to $T_k$ to construct $T_{k+1}$, there are three cases; $(1)$ incoming,
		$(2)$ outgoing, and $(3)$ two-sided. When $\alpha$ is either incoming or two-sided arrow, then it follows from Lemma
		~\ref{proposition: gluing an arrow proposition} that $\Pic(T_k)=\Pic(T_{k+1})=\mathbb{Z}^n$, where $n$ is the
		number of sinks of $T_k$ and $T_{k+1}$, since in this case it does not increase the number of sinks.

		Next, suppose that $\alpha$ is an outgoing arrow. In this case, $T_{k+1}$ has one more sink than $T_{k}$.
		We claim that $\Pic(T_{k+1})=\Pic(T_k)\times \mathbb{Z}$. We label the vertexes of $G$ as $1,2,\dots,n$ and
		suppose that the arrow $\alpha$ is attached to the vertex $n$. Let $A_{T_k}=(a_{ij})$ be the Laplacian of $T_k$.
		Then we have the following:
		\begin{equation}\label{eq: tree case}
			A_{T_{k+1}}=\left[\begin{array}{ccc|c|c}
				a_{11}&a_{12}&\cdots &a_{1n}&0\\
				a_{21}&a_{22}&\cdots &a_{2n}&0\\
				\vdots & \vdots &\ddots & \vdots & \vdots \\ \hline
				\vdots & \vdots & \cdots&a_n+1 & -1\\ \hline
				0&0&\cdots &0&0\\
			\end{array}\right]
		\end{equation}
		\textcolor{red}{Jaiung: I will finish writing down the proof before our next meeting.}
	\end{proof}


\section{Describing The Picard Group for a Cycle}

	\subsection{Representing Single Term Jacobians}
		\begin{conj}
			Let $C_n$ be the cycle graph with $n$ vertices. For each $k \leq n$, there exists an orientation of $C_n$
			such that $\Jac(C_n)$ (with that orientation) is $\mathbb{Z}_k$.
		\end{conj}
		\begin{proof}
			We have proven this experimentally for cycles using two methods.  For the first, we proved this for
			$C_3 \dots C_{30}$ by testing out all possible orientations for each size of cycle graph until at least one
			of each $\Jac(C_n)=\mathbb{Z}_k$ has been found.  By using our second method, we proved this for
			$C_3\dotsC_{80}$ by only looking as specific orientations of two path cycle graphs of size $n$.
		\end{proof}

		The following examples shows the conjecture for $C_3$.

		\begin{myeg}
			%cycle = Graph.cycle(3)
			%cycle.setEdgeState(0, 1, 2)
			%cycle.setEdgeState(1, 2, 2)
			%cycle.setEdgeState(2, 0, 2)
			%Trivial

			%cycle = Graph.cycle(3)
			%cycle.setEdgeState(0, 1, 1)
			%cycle.setEdgeState(1, 2, 2)
			%cycle.setEdgeState(2, 0, 2)
			%Z_2

			%cycle = Graph.cycle(3)
			%cycle.setEdgeState(0, 1, 0)
			%cycle.setEdgeState(1, 2, 0)
			%cycle.setEdgeState(2, 0, 0)
			%Z_3
		\end{myeg}

		The number of paths in the cycle graph also plays a role in if it can represent all single term Jacobians up
		to $\mathbb{Z}_n$.

		\begin{conj}
			For any cycle graph $C_n$, the orientation with no paths always has a Jacobian of $\mathbb{Z}_n$.
			Either of the single path orientations have a trivial Jacobian.
			The set of all orientations with two paths always contains all single invariant factors
			$\mathbb{Z}_2\dots\mathbb{Z}_n$.  For all graphs at least up to $C_{10}$ and likely well beyond that
			point, the sets that contain all other paths do not contain all of the single invariant factors.
		\end{conj}

		It should be noted that for four paths and upward, the sets that contain these paths often also contain
		Jacobians of $\mathbb{Z}_3$ and $\mathbb{Z}_4$.  The number of each of these increases with the size of the
		graph, so it is possible that these sets will contain all of the single invariant factors for very
		large cycle graphs.

	\subsection{Describing Two Path Cycle Graphs}
		Here, a \emph{path} represents a region of a cycle graph in which all arrows are oriented in a single
		direction or are bidirectional.  In graphs with exactly two of these paths, a consistent pattern arises
		that allows for the rapid calculation of the Jacobian in only $O(n)$ time compared to the $O(n^4)$ time
		that calculating the smith normal form takes. This pattern relies on calculating the number
		of bidirectional arrows between these two paths on one side.

		\begin{conj}
			For any given cycle graph, $\Jac(G)=\mathbb{Z}_{x-2}$, where $x$ is the number of
			bidirectional edges clockwise of the counter-clockwise path and counter-clockwise of the clockwise path.
		\end{conj}
		\begin{proof}
			We have proven this completely for cycle graphs up to $C_{80}$ when using two continuous paths without
			any bidirectional arrows separating them on the other size.  This has also held true for many other
			arbitrary orientations that still meet the two-path definition.
		\end{proof}

		This holds true for nearly every graph tested, with very few exceptions.

	\subsection{Representing The Rank of the Picard Group for Cycle Graphs}
		The following example shows that the rank of $\Pic(C_n)$ (with an orientation) does not have to be $1$;
		this directly follows from~\cite[Corollary 3.5]{wagner2000critical}.

		\begin{myeg}
			%cycle = Graph.cycle(9)
			%cycle.setEdgeState(0, 1, 0)
			%cycle.setEdgeState(1, 2, 1)
			%cycle.setEdgeState(2, 3, 1)
			%cycle.setEdgeState(3, 4, 2)
			%cycle.setEdgeState(4, 5, 2)
			%cycle.setEdgeState(5, 6, 1)
			%cycle.setEdgeState(6, 7, 1)
			%cycle.setEdgeState(7, 8, 2)
			%cycle.setEdgeState(8, 0, 2)
			%Rank(Pic(G)) = 2: 2 terminal strong components
		\end{myeg}

		$\Pic(G)$ is often in the form $\mathbb{Z}_1 \times \dots \times \mathbb{Z}_n \times \mathbb{Z}^m$ where $m$ is
		the rank of the picard group.  A terminal strong component describes itself well.  It is a terminal component,
		meaning that its only connections are edges directed into it.  It is also strongly connected, meaning that every
		vertex in the component has at least one path to all other components.  For cycle graphs and trees, the number
		of these terminal strong components is exactly equal to $Rank(\Pic(G))$.

		\begin{proof}
			The $Rank(\Pic(G))$ comes directly from the number of all zero rows of the Smith Normal Form of the laplacian of
			$G$.  Terminal strong components are either already zero rows (in the case of a single sink) or there
			exists a series of row and column operations that, when preformed on the laplacian result in a row of all
			zeroes.
		\end{proof}

	\begin{lem}
		Let $C_n$ be the cycle graph with $n$ vertices. Consider the equi-orientation of $C_n$.
		Then $\Pic(C_n)=\mathbb{Z}$.
	\end{lem}
	\begin{proof}
		In this case $C_n$ will always have a laplacian with a diagonal of $1$ and a diagonal of $-1$
		above or below it depending on the orientation, with another $-1$ in the top right or bottom left corner
		where $V_0$ connects $V_{n-1}$.  Turing this laplacian into a smith normal form of all $1$s is as simple as
		cascading additions from the first row in a counter-clockwise case and the last row in the clockwise case.
		This will result in a diagonal of ones with the first or last column made up of mostly $-1$.  From here
		all that needs to be done is to eliminate these with the first or last row.  Since each equi-oriented $C_n$
		will follow this pattern, this algorithm will prove $\Pic(C_n)=\mathbb{Z}$ for all $C_n$.
	\end{proof}

\section{Example: Pseudotrees}

	\textcolor{red}{Jaiung: here we study how Picard groups change when we glue two directed graphs along one vertex or
		connect two graphs along one arrow. If we are lucky this should provide a way to compute Picard groups for
		pseudotrees by using the tree case and the cycle case in the previous sections.}

\section{Describing The Picard Group for a Wheel}

	\subsection{Patterns in The Jacobian}
		For wheel graphs, we looked for patterns that arose within the invariant factors of the Jacobian as
		a general formula was not immediately obvious.  For this strategy, we broke the edges of the wheel graph into
		their two most obvious groups, those belonging to the rim of the wheel and those of the spokes.  By orienting
		all the edges of either group the same way and trying all nine combinations, we noticed a well-defined pattern
		for each as the size of the wheel graph changed.  These patterns fell into four distinct groups.

		\begin{enumerate}
			\item When the spoke edges all pointed towards the axel and the rim was not bidirectional, or when
			the spoke edges were bidirectional, but the rim was not then a graph of size $n$ had a
			Jacobian of $\mathbb{Z}_{2^(n-1)-1}$.
			\item When the spoke edges all pointed away from the axel and the rim was not bidirectional,
			a graph of size $n$ had a Jacobian of $\mathbb{Z}_{n-1}$.
			\item When the spoke edges point away from the axel and the rim was bidirectional and a graph of size
			$n$ had a Jacobian of $\mathbb{Z}_{n-1} \times \mathbb{Z}_{n-1}$ when $n$ was even
			and $Z_{\frac{n-1}{2}} x Z_{(n-1) \times 2}$ when $n$ was odd.
			\item When all edges were bidirectional or when the spoke direction was towards the axel and
			the rim was bidirectional, a graph of size $n$ had a Jacobian of
			$\mathbb{Z}_{\alpha\phi^{n}} \times \mathbb{Z}_{5\alpha\phi^{n}}$ when the size
			was odd where $\alpha \approxeq 0.27555$ and $\mathbb{Z}_{\beta\phi^{n}} \times \mathbb{Z}_{\beta\phi^{n}}$
			when the size was even where $\beta \approxeq 0.618035$. In both of these patterns,
			$\phi$ represents the golden ratio.
		\end{enumerate}
\bibliography{Jacobian}
\bibliographystyle{alpha}

\end{document}
